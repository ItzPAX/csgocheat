#pragma once
#include "IMaterial.h"
#include "IAppSystem.h"

using MaterialHandle_t = std::uint16_t;

#define DECLARE_POINTER_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#define MAXSTUDIOSKINS		32

enum CompiledVtfFlags
{
	// Flags from the *.txt config file
	TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
	TEXTUREFLAGS_TRILINEAR = 0x00000002,
	TEXTUREFLAGS_CLAMPS = 0x00000004,
	TEXTUREFLAGS_CLAMPT = 0x00000008,
	TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
	TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
	TEXTUREFLAGS_PWL_CORRECTED = 0x00000040,
	TEXTUREFLAGS_NORMAL = 0x00000080,
	TEXTUREFLAGS_NOMIP = 0x00000100,
	TEXTUREFLAGS_NOLOD = 0x00000200,
	TEXTUREFLAGS_ALL_MIPS = 0x00000400,
	TEXTUREFLAGS_PROCEDURAL = 0x00000800,

	// These are automatically generated by vtex from the texture data.
	TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
	TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,

	// Newer flags from the *.txt config file
	TEXTUREFLAGS_ENVMAP = 0x00004000,
	TEXTUREFLAGS_RENDERTARGET = 0x00008000,
	TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
	TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
	TEXTUREFLAGS_SINGLECOPY = 0x00040000,

	TEXTUREFLAGS_SRGB = 0x00080000, //SRGB correction has already been applied to this texture.

	TEXTUREFLAGS_DEFAULT_POOL = 0x00100000, // Nvidia Stereo Change: Water (Force a texture to the default pool)

	TEXTUREFLAGS_COMBINED = 0x00200000,

	TEXTUREFLAGS_ASYNC_DOWNLOAD = 0x00400000,

	TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,

	TEXTUREFLAGS_SKIP_INITIAL_DOWNLOAD = 0x01000000, // Skip initial download when creating a procedural texture

	TEXTUREFLAGS_CLAMPU = 0x02000000,
	TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,	// Usable as a vertex texture
	TEXTUREFLAGS_SSBUMP = 0x08000000,

	TEXTUREFLAGS_MOST_MIPS = 0x10000000, // Don't load the bottom few mips at runtime

	TEXTUREFLAGS_BORDER = 0x20000000,	// Clamp to border color on all texture coordinates

#if defined( _PS3 ) || defined SPU
	// PS3 extensions
	TEXTUREFLAGS_QUINCUNX = 0x40000000,
	TEXTUREFLAGS_QUINCUNX_ALT = 0x80000000,
#elif defined( _X360 )
	TEXTUREFLAGS_ALIAS_COLOR_AND_DEPTH_SURFACES = 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
#else
	TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
#endif
};

enum VersionedVtfFlags
{
	VERSIONED_VTF_FLAGS_MASK_7_3 = ~0xD1780400,	// For a ver 7.3 or earlier only these flags are valid
};


// These are given to FindMaterial to reference the texture groups that Show up on the
#define TEXTURE_GROUP_LIGHTMAP				"Lightmaps"
#define TEXTURE_GROUP_WORLD				"World textures"
#define TEXTURE_GROUP_MODEL				"Model textures"
#define TEXTURE_GROUP_VGUI				"VGUI textures"
#define TEXTURE_GROUP_PARTICLE				"Particle textures"
#define TEXTURE_GROUP_DECAL				"Decal textures"
#define TEXTURE_GROUP_SKYBOX				"SkyBox textures"
#define TEXTURE_GROUP_CLIENT_EFFECTS			"ClientEffect textures"
#define TEXTURE_GROUP_OTHER				"Other textures"
#define TEXTURE_GROUP_PRECACHED				"Precached"
#define TEXTURE_GROUP_CUBE_MAP				"CubeMap textures"
#define TEXTURE_GROUP_RENDER_TARGET			"RenderTargets"
#define TEXTURE_GROUP_UNACCOUNTED			"Unaccounted textures"
//#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER		"Static Vertex"
#define TEXTURE_GROUP_STATIC_INDEX_BUFFER		"Static Indices"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_DISP		"Displacement Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_COLOR	"Lighting Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_WORLD	"World Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_MODELS	"Model Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_OTHER	"Other Verts"
#define TEXTURE_GROUP_DYNAMIC_INDEX_BUFFER		"Dynamic Indices"
#define TEXTURE_GROUP_DYNAMIC_VERTEX_BUFFER		"Dynamic Verts"
#define TEXTURE_GROUP_DEPTH_BUFFER			"DepthBuffer"
#define TEXTURE_GROUP_VIEW_MODEL			"ViewModel"
#define TEXTURE_GROUP_PIXEL_SHADERS			"Pixel Shaders"
#define TEXTURE_GROUP_VERTEX_SHADERS			"Vertex Shaders"
#define TEXTURE_GROUP_RENDER_TARGET_SURFACE		"RenderTarget Surfaces"
#define TEXTURE_GROUP_MORPH_TARGETS			"Morph Targets"

//-----------------------------------------------------------------------------
// Flags to specify type of depth buffer used with RT
//-----------------------------------------------------------------------------

// GR - this is to add RT with no depth buffer bound

enum MaterialRenderTargetDepth_t
{
	MATERIAL_RT_DEPTH_SHARED = 0x0,
	MATERIAL_RT_DEPTH_SEPARATE = 0x1,
	MATERIAL_RT_DEPTH_NONE = 0x2,
	MATERIAL_RT_DEPTH_ONLY = 0x3,
};

//-----------------------------------------------------------------------------
// A function to be called when we need to release all vertex buffers
// NOTE: The restore function will tell the caller if all the vertex formats
// changed so that it can flush caches, etc. if it needs to (for dxlevel support)
//-----------------------------------------------------------------------------
enum RestoreChangeFlags_t
{
	MATERIAL_RESTORE_VERTEX_FORMAT_CHANGED = 0x1,
	MATERIAL_RESTORE_RELEASE_MANAGED_RESOURCES = 0x2,
};


// NOTE: All size modes will force the render target to be smaller than or equal to
// the size of the framebuffer.
enum RenderTargetSizeMode_t
{
	RT_SIZE_NO_CHANGE = 0,			// Only allowed for render targets that don't want a depth buffer
	// (because if they have a depth buffer, the render target must be less than or equal to the size of the framebuffer).
	RT_SIZE_DEFAULT = 1,				// Don't play with the specified width and height other than making sure it fits in the framebuffer.
	RT_SIZE_PICMIP = 2,				// Apply picmip to the render target's width and height.
	RT_SIZE_HDR = 3,					// frame_buffer_width / 4
	RT_SIZE_FULL_FRAME_BUFFER = 4,	// Same size as frame buffer, or next lower power of 2 if we can't do that.
	RT_SIZE_OFFSCREEN = 5,			// Target of specified size, don't mess with dimensions
	RT_SIZE_FULL_FRAME_BUFFER_ROUNDED_UP = 6 // Same size as the frame buffer, rounded up if necessary for systems that can't do non-power of two textures.
};


enum AntiAliasingHintEnum_t
{
	AA_HINT_MESHES,
	AA_HINT_TEXT,
	AA_HINT_DEBUG_TEXT,
	AA_HINT_HEAVY_UI_OVERLAY,
	AA_HINT_ALIASING_PUSH,
	AA_HINT_ALIASING_POP,
	AA_HINT_POSTPROCESS,
	AA_HINT_MOVIE,
	AA_HINT_MENU
};

using MaterialHandle = unsigned short;
class ITexture;

class IMaterialSystem : IAppSystem {
public:
	ITexture* CreateRenderTargetFF(const char* name, int w, int h, RenderTargetSizeMode_t sizeMode, ImageFormat format, MaterialRenderTargetDepth_t depth = MATERIAL_RT_DEPTH_SHARED, unsigned int textureFlags = TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT, unsigned int renderTargetFlags = 0) {
		using fn = ITexture * (__thiscall*)(IMaterialSystem*, char const*, int, int, RenderTargetSizeMode_t, ImageFormat, MaterialRenderTargetDepth_t, unsigned int, unsigned int);
		return (*(fn**)this)[97](this, name, w, h, sizeMode, format, depth, textureFlags, renderTargetFlags);
	}

	ImageFormat GetBackBufferFormat() {
		using fn = ImageFormat(__thiscall*)(IMaterialSystem*);
		return (*(fn**)this)[36](this);
	}

	IMaterial* FindMaterial(char const* material_name, const char* group_name, bool complain = true, const char* complain_prefix = 0) {
		using fn = IMaterial * (__thiscall*)(IMaterialSystem*, char const*, const char*, bool, const char*);
		return (*(fn**)this)[84](this, material_name, group_name, complain, complain_prefix);
	}
	MaterialHandle FirstMaterial() {
		using fn = MaterialHandle(__thiscall*)(IMaterialSystem*);
		return (*(fn**)this)[86](this);
	}
	MaterialHandle NextMaterial(MaterialHandle handle) {
		using fn = MaterialHandle(__thiscall*)(IMaterialSystem*, MaterialHandle);
		return (*(fn**)this)[87](this, handle);
	}
	MaterialHandle InvalidMaterial() {
		using fn = MaterialHandle(__thiscall*)(IMaterialSystem*);
		return (*(fn**)this)[88](this);
	}
	IMaterial* GetMaterial(MaterialHandle handle) {
		using fn = IMaterial * (__thiscall*)(IMaterialSystem*, MaterialHandle);
		return (*(fn**)this)[89](this, handle);
	}
	int GetMaterialsCount() {
		using fn = int(__thiscall*)(IMaterialSystem*);
		return (*(fn**)this)[90](this);
	}

	void BeginRenderTargetAllocation() {
		using fn = void(__thiscall*)(IMaterialSystem*);
		(*(fn**)this)[94](this);
	}

	void FinishRenderTargetAllocation() {
		using fn = void(__thiscall*)(IMaterialSystem*);
		(*(fn**)this)[136](this);
	}

	ITexture* FindTexture(const char* name, const char* groupname, int complain = true, int addcreationflags = 0) {
		using fn = ITexture*(__thiscall*)(IMaterialSystem*, const char*, const char*, int, int);
		return (*(fn**)this)[91](this, name, groupname, complain, addcreationflags);
	}

	IMatRenderContext* GetRenderContext() {
		using fn = IMatRenderContext*(__thiscall*)(IMaterialSystem*);
		return (*(fn**)this)[115](this);
	}
};